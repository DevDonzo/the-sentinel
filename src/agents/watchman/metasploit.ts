/**
 * Metasploit Scanner for Warden DAST
 *
 * Penetration testing and vulnerability validation using Metasploit Framework
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import * as path from 'path';
import { logger } from '../../utils/logger';
import { Vulnerability, ScanResult, MetasploitConfig, DastTarget, SafetyConfig } from '../../types';

const execAsync = promisify(exec);

export class MetasploitScanner {
    private config: MetasploitConfig;
    private target: DastTarget;
    private safetyConfig: SafetyConfig;
    private outputDir: string;

    constructor(
        config: MetasploitConfig,
        target: DastTarget,
        safetyConfig: SafetyConfig,
        outputDir: string = 'scan-results/dast'
    ) {
        this.config = config;
        this.target = target;
        this.safetyConfig = safetyConfig;
        this.outputDir = outputDir;
    }

    /**
     * Check if Metasploit Framework is installed
     */
    async checkInstallation(): Promise<{ installed: boolean; version?: string }> {
        try {
            const { stdout } = await execAsync('msfconsole --version');
            const versionMatch = stdout.match(/metasploit v([0-9.]+)/i) || stdout.match(/([0-9.]+)/);
            const version = versionMatch ? versionMatch[1] : 'unknown';
            logger.info(`Metasploit Framework detected: version ${version}`);
            return { installed: true, version };
        } catch (error) {
            logger.error('Metasploit Framework not found. Please install msfconsole to use this feature.');
            return { installed: false };
        }
    }

    /**
     * Display comprehensive safety warnings
     */
    displaySafetyWarning(): void {
        const warning = `
┌─────────────────────────────────────────────────────────────────────┐
│                    ⚠️  METASPLOIT SAFETY WARNING ⚠️                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  LEGAL NOTICE:                                                      │
│  • Only scan systems you own or have written authorization to test │
│  • Unauthorized scanning may violate Computer Fraud and Abuse Act  │
│  • Ensure compliance with local laws and regulations               │
│                                                                     │
│  SCAN CONFIGURATION:                                                │
│  • Target: ${this.target.url.padEnd(56)} │
│  • Mode: ${this.config.mode.padEnd(58)} │
│  • Safety: ${(this.safetyConfig.disableExploits ? 'Exploits DISABLED' : 'Exploits ENABLED').padEnd(55)} │
│                                                                     │
│  By proceeding, you confirm that you have proper authorization     │
│  to perform security testing on this target.                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
        `;

        console.log(warning);
        logger.warn('Metasploit scan initiated - ensure proper authorization');
    }

    /**
     * Generate Metasploit resource script
     */
    private async generateResourceScript(nmapResults?: Vulnerability[]): Promise<string> {
        const url = new URL(this.target.url);
        const targetHost = url.hostname;
        const targetPort = url.port || (url.protocol === 'https:' ? '443' : '80');

        const scriptLines: string[] = [
            '# Metasploit Resource Script - Generated by Warden',
            `# Target: ${this.target.url}`,
            `# Mode: ${this.config.mode}`,
            `# Timestamp: ${new Date().toISOString()}`,
            '',
            '# Set global options',
            `setg RHOSTS ${targetHost}`,
            `setg RPORT ${targetPort}`,
            'setg VERBOSE true',
            ''
        ];

        // Select modules based on mode and nmap results
        const modules = this.selectModules(nmapResults);

        for (const module of modules) {
            scriptLines.push(`use ${module}`);
            scriptLines.push('run');
            scriptLines.push('');
        }

        scriptLines.push('exit');

        return scriptLines.join('\n');
    }

    /**
     * Select appropriate Metasploit modules based on mode and discovered services
     */
    private selectModules(nmapResults?: Vulnerability[]): string[] {
        const modules: string[] = [];

        // Start with safe auxiliary modules
        if (this.config.mode === 'scan-only' || !this.safetyConfig.disableExploits) {
            // Port scanning
            modules.push('auxiliary/scanner/portscan/tcp');

            // Service detection
            if (nmapResults) {
                for (const vuln of nmapResults) {
                    const service = vuln.service?.toLowerCase();

                    switch (service) {
                        case 'http':
                        case 'https':
                            modules.push('auxiliary/scanner/http/http_version');
                            modules.push('auxiliary/scanner/http/http_header');
                            modules.push('auxiliary/scanner/http/robots_txt');
                            break;
                        case 'ssh':
                            modules.push('auxiliary/scanner/ssh/ssh_version');
                            break;
                        case 'ftp':
                            modules.push('auxiliary/scanner/ftp/ftp_version');
                            break;
                        case 'smtp':
                            modules.push('auxiliary/scanner/smtp/smtp_version');
                            break;
                        case 'mysql':
                            modules.push('auxiliary/scanner/mysql/mysql_version');
                            break;
                        case 'postgresql':
                            modules.push('auxiliary/scanner/postgres/postgres_version');
                            break;
                    }
                }
            }
        }

        // Add safe-exploits modules (non-destructive verification)
        if (this.config.mode === 'safe-exploits' && !this.safetyConfig.disableExploits) {
            modules.push('auxiliary/scanner/http/ssl_version');
            modules.push('auxiliary/scanner/http/http_login');
        }

        // Add custom modules if specified
        if (this.config.modules && this.config.modules.length > 0) {
            modules.push(...this.config.modules);
        }

        // Remove duplicates
        return [...new Set(modules)];
    }

    /**
     * Execute Metasploit scan
     */
    async scan(nmapResults?: Vulnerability[]): Promise<ScanResult> {
        const startTime = Date.now();

        // Check authorization
        if (!this.target.authorized) {
            throw new Error(`Target ${this.target.url} is not authorized for scanning. Set "authorized: true" in configuration.`);
        }

        // Enforce safety checks
        if (this.safetyConfig.authorizedTargetsOnly && !this.target.authorized) {
            throw new Error('Safety configuration requires explicit authorization for all targets');
        }

        // Check Metasploit installation
        const { installed, version } = await this.checkInstallation();
        if (!installed) {
            throw new Error('Metasploit Framework is not installed. Please install msfconsole to continue.');
        }

        // Display safety warning
        if (this.safetyConfig.requireConfirmation) {
            this.displaySafetyWarning();
        }

        // Create output directory
        await fs.mkdir(this.outputDir, { recursive: true });

        // Generate resource script
        const resourceScript = await this.generateResourceScript(nmapResults);
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const resourceScriptPath = path.join(this.outputDir, `msf-resource-${timestamp}.rc`);
        const outputPath = path.join(this.outputDir, `msf-output-${timestamp}.txt`);

        await fs.writeFile(resourceScriptPath, resourceScript);

        logger.info(`Metasploit resource script generated: ${resourceScriptPath}`);

        try {
            // Execute Metasploit
            const timeout = this.config.timeout || 60000;
            const command = `msfconsole -q -r ${resourceScriptPath} -o ${outputPath}`;

            logger.info(`Executing Metasploit: ${command}`);

            await execAsync(command, {
                timeout,
                maxBuffer: 10 * 1024 * 1024 // 10MB buffer
            });

            // Parse output
            const outputContent = await fs.readFile(outputPath, 'utf-8');
            const vulnerabilities = this.parseMetasploitOutput(outputContent);

            const duration = Date.now() - startTime;

            const result: ScanResult = {
                timestamp: new Date().toISOString(),
                vulnerabilities,
                summary: this.calculateSummary(vulnerabilities),
                scanner: 'metasploit',
                projectPath: this.target.url,
                scanMode: 'dast',
                scanMetadata: {
                    target: this.target.url,
                    scanType: this.config.mode,
                    duration,
                    msfVersion: version,
                    outputFile: outputPath,
                    resourceScript: resourceScriptPath
                }
            };

            logger.info(`Metasploit scan completed. Found ${vulnerabilities.length} findings in ${duration}ms`);

            // Cleanup resource script if needed
            // await fs.unlink(resourceScriptPath);

            return result;

        } catch (error) {
            logger.error(`Metasploit scan failed: ${error}`);
            throw error;
        }
    }

    /**
     * Parse Metasploit console output
     */
    private parseMetasploitOutput(output: string): Vulnerability[] {
        const vulnerabilities: Vulnerability[] = [];
        const lines = output.split('\n');

        let currentModule = '';
        const findings: Map<string, string[]> = new Map();

        for (const line of lines) {
            // Detect module usage
            const moduleMatch = line.match(/\[.*\]\s+use\s+(\S+)/);
            if (moduleMatch) {
                currentModule = moduleMatch[1];
                findings.set(currentModule, []);
            }

            // Detect successful findings
            if (line.includes('[+]') || line.includes('[*]')) {
                const finding = line.trim();
                if (currentModule && findings.has(currentModule)) {
                    findings.get(currentModule)!.push(finding);
                }
            }

            // Detect vulnerabilities
            if (line.toLowerCase().includes('vulnerable') ||
                line.toLowerCase().includes('exploit') ||
                line.toLowerCase().includes('success')) {

                const url = new URL(this.target.url);
                const targetHost = url.hostname;

                vulnerabilities.push({
                    id: `msf-${currentModule.replace(/\//g, '-')}-${Date.now()}`,
                    title: `Metasploit Finding: ${currentModule}`,
                    severity: this.determineSeverityFromModule(currentModule),
                    packageName: currentModule.split('/').pop() || 'unknown',
                    version: 'n/a',
                    fixedIn: [],
                    description: `Metasploit module ${currentModule} detected potential vulnerability`,
                    targetHost,
                    service: this.extractServiceFromModule(currentModule),
                    exploitAvailable: true,
                    exploitModule: currentModule,
                    findings: findings.get(currentModule) || []
                });
            }
        }

        return vulnerabilities;
    }

    /**
     * Determine severity based on module type
     */
    private determineSeverityFromModule(module: string): 'critical' | 'high' | 'medium' | 'low' {
        if (module.includes('exploit')) {
            return 'critical';
        } else if (module.includes('auxiliary/scanner') && module.includes('login')) {
            return 'high';
        } else if (module.includes('auxiliary/scanner')) {
            return 'medium';
        }
        return 'low';
    }

    /**
     * Extract service name from module path
     */
    private extractServiceFromModule(module: string): string {
        const parts = module.split('/');
        if (parts.length >= 3) {
            return parts[2]; // e.g., auxiliary/scanner/http -> http
        }
        return 'unknown';
    }

    /**
     * Calculate vulnerability summary
     */
    private calculateSummary(vulnerabilities: Vulnerability[]) {
        return {
            total: vulnerabilities.length,
            critical: vulnerabilities.filter(v => v.severity === 'critical').length,
            high: vulnerabilities.filter(v => v.severity === 'high').length,
            medium: vulnerabilities.filter(v => v.severity === 'medium').length,
            low: vulnerabilities.filter(v => v.severity === 'low').length
        };
    }
}
